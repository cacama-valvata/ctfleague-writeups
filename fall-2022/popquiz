`popquiz` is an introductory challenge intended to teach reverse engineering skills and familiarity with Ghidra.

First off, we're given a Linux executable, which we can run, AND we can open this in Ghidra to analyze. Having the executable locally will also help us testing our solutions, because the server hosted executable makes you wait before you can try again. First, let's open this file in Ghidra and analyze it as an ELF.

After opening it in Ghidra, we can peruse the function list in the left column. The first thing we should look at is the `main` function as this is where the program starts. Here we see that we need question_1(), question_2(), and question_3() to not return 0 in order to read the flag out from the server. Now, let's take a look at each smaller function. Also remember that in C, Boolean values are really 0 and not 0, so these functions likely need to return true and not false.

For question_1(), the C code is rather simple. It returns whether local_14 == local_18, where both variables are integers. Looking a little before that, we can see that local_14 is a constant, and local_18 is obtained from the user via scanf. The user input must equal the value of local_14 which is 0x2325. Translating from hex, our answer for question 1 is 8997.

For question_2(), this is a little more complicated. The first thing we should notice is that it wants a string of characters. Looking at the scanf statement, it specifically wants four characters, and it fills this into the array of characters. The function then checks if the addition of all four characters equals a constant 0x1a0. This may seem strange: didn't we input characters, not integers? However, the `char` type is *actually* an 8-bit integer, so it is totally possible to add together characters. This 0x1a0 equals 416 in decimal. Many combinations work for this, but for ease, I just divided 416 by 4: we need a character with an ASCII decimal value of 104. Looking at an ASCII table (which is googleable), we find 104 on the chart under the decimal column, and move over to the character column: this a lowercase h! So our answer for question 2 is hhhh.

For question_3(), this is a LOT trickier. Not only do we not have a prompt to hint at us what the input is supposed to be, but the function that question_3() calls (`check()`) is 60 lines long with more than one loop to parse. When we go through this code, our user input that we want to pay attention to is param_1. There's a lot going on in the first several lines of this, let's skip down to the first mention of param_1, on line 26. In this line, the program uses sprintf to format the integer into a string variable (char array) called local_118. Something nice about ghidra is the ability to rename variables. So let's call local_118 `str_param` because its the string version of the parameter. Next, sVar3 is the returned value of strnlen on this string - the number of characters of this string of a number. So let's call sVar3 `num_digits` and similiarly iVar2 is just a copy, so lets call that iVar2 'also_num_digits'. 

Our if statement at line 29 does bitwise AND between num_digits and 0x1, and whether this equals 0. This overall means "if this number does not have an extra one at the end" - fancy words for "if the number of digits is even, then proceed." This is our first qualification for the answer to this question. Next, at line 30, we check if the number of digits is less than 4, then our returning value (uVar2 == `retval`) is zero. So our next qualification is that the number of digits is 4 or more. Now into the first loop at line 34. We see local_128 but this is a for loop so this is probably actually a variable like `i`. Our pretty standard for loop here is counting from 1 to `also_num_digits`/2. We also notice a variable is set (its only set once because the for loop does not affect it: iVar1 = also_num_digits / 2. Let's call iVar1 `half_num_digits`. 

We want to look at line 35 carefully. If at any point in the loop, the if statement is true, we return a zero. This if statement also has some tricky pointer math: remember that *name means get the value of name (as a pointer), while &name gets the address of name (as a variable). On the left side of the boolean expression: notice that we get the address of the str_param then add i (1, 2, 3, etc) to it. This increments the pointer, and str_param is a char array. We then dereference that address, getting the value of the character at that address. This is equivalent to writing str_param[i]. The right side of the boolean expression is very similar but instead of simply adding i, we add i - 1 to the address of str_param and then get the value at that address. Putting this altogether we get `if (str_param[i] <= str_param[i - 1]: return false`. This is another round of ASCII character value comparison, so our next qualification for this number is that each (ASCII-ized) digit is greater than the one before it. BUT this only goes for the first half of the string.

The next loop is a funky do-while loop. Let's go straight into it. Line 41 assigns another variable: `local_124 = half_num_digits + 1`. Let's call local_124 `j` because on every loop, it will increase by one (line 47). Note that lines 42-45 hold our key to returning true: if j is greater than or equal to the number of digits: we need to get to the end of the loop without the expression of the do-while loop returning false (line 48). Let's go through the rest of the lines starting at 46. On line 47, half_num_digits is set equal to j: the current half_num_digits + 1. That variable is now being used as an iterator but let's not change its name for consistency. On line 46 before it then, lets name lVar1 to `current_index`. Now for the expression on Line 49. We again have ASCII value comparisons in the string in the same manner as before. This evaluates to `str_param[j] < str_param[current_iteration]`. Remember that `j = half_num_digits + 1` and `current_iteration = half_num_digits`. So what this really evaluates to is `str_param[j] < str_param[j - 1]`. This means that we want each digit in the second half of this string to be greater than the digit that after it, until the end. When we get to the end, we set the retval to 1, break out of the loop, and return. 

So here are the current rules for the third question's answer:
1. The number must have an even number of digits
2. It must be four or more digits in length
3. First half of digits: the digits must increase in value left to right
4. Second half of digits: the digits must decrease in value left to right

This leads us to an answer like `12343210`. Now that we have all our answers to our questions, we can connect to the remote server and submit our answers to the quiz: nc chal.ctf-league.osusec.org 31300. Input 8997, hhhh, and 12343210, and the quiz spits out our flag for us: osu{e@s13r_th@n_ph21x_s3r13s}

